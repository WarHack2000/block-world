<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block World</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
        }
        h1 {
            color: #fff;
            text-shadow: 4px 4px 0 #e63946, 8px 8px 0 rgba(0,0,0,0.3);
            font-size: 2.5rem;
            margin-bottom: 5px;
            letter-spacing: 4px;
        }
        .subtitle { color: #90e0ef; font-size: 0.9rem; margin-bottom: 10px; letter-spacing: 3px; }
        #gameCanvas { border: 6px solid #f9c74f; border-radius: 10px; box-shadow: 0 0 30px rgba(249, 199, 79, 0.3); }
        .score-board { display: flex; gap: 15px; margin-top: 10px; color: #fff; font-size: 0.85rem; flex-wrap: wrap; justify-content: center; }
        .score-item { background: rgba(255,255,255,0.1); padding: 8px 14px; border-radius: 20px; border: 2px solid #0077b6; }
        .score-item span { color: #f9c74f; }
        .lives span { color: #e63946; }
        .level span { color: #2d6a4f; }
        .ability { border-color: #7b2cbf; }
        .ability span { color: #c77dff; }
        .controls { color: #90e0ef; margin-top: 10px; font-size: 0.8rem; font-family: Arial, sans-serif; text-align: center; }
        .game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); padding: 30px 50px; border-radius: 20px;
            border: 4px solid #e63946; text-align: center; display: none; z-index: 100;
        }
        .game-over h2 { color: #e63946; font-size: 2rem; margin-bottom: 15px; }
        .game-over.win h2 { color: #2d6a4f; }
        .game-over.boss h2 { color: #7b2cbf; }
        .game-over p { color: #fff; font-size: 1.1rem; margin-bottom: 10px; }
        .restart-btn {
            background: #2d6a4f; color: #fff; border: none; padding: 12px 30px;
            font-size: 1rem; font-family: 'Arial Black', sans-serif; border-radius: 10px;
            cursor: pointer; transition: transform 0.2s, background 0.2s; margin: 5px;
        }
        .restart-btn:hover { background: #40916c; transform: scale(1.1); }
        .next-btn { background: #0077b6; }
        .next-btn:hover { background: #00b4d8; }
    </style>
</head>
<body>
    <h1>BLOCK WORLD</h1>
    <p class="subtitle">100 LEVELS - 4 BOSSES - 4 ABILITIES</p>
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    <div class="score-board">
        <div class="score-item level">LEVEL: <span id="level">1</span>/100</div>
        <div class="score-item">STUDS: <span id="score">0</span></div>
        <div class="score-item lives">LIVES: <span id="lives">3</span></div>
        <div class="score-item">CHAR: <span id="character">ADVENTURER</span></div>
        <div class="score-item ability">ABILITY: <span id="abilityName">DOUBLE JUMP</span> [E]</div>
        <div class="score-item ability">COOLDOWN: <span id="cooldown">READY</span></div>
    </div>
    <p class="controls">ARROWS/WASD: Move | SPACE: Jump | E: Use Ability | 1-4: Switch Character | BOSSES at levels 25, 50, 75, 100!</p>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p>Score: <span id="finalScore">0</span> | Enemies: <span id="enemiesDefeated">0</span></p>
        <p id="bossText"></p>
        <div id="buttonContainer">
            <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let score = 0, lives = 3, enemiesKilled = 0, currentLevel = 1;
        const maxLevel = 100;
        let gameRunning = true, invincible = false, invincibleTimer = 0;
        let celebrating = false, hotdogs = [];
        let abilityCooldown = 0, abilityActive = false, abilityTimer = 0;

        // Character types with abilities
        const characters = [
            { name: 'ADVENTURER', bodyColor: '#e63946', headColor: '#f4c45a', hairColor: '#8B4513', hasHelmet: false, hasMask: false, hasWizardHat: false,
              ability: 'DOUBLE JUMP', abilityDesc: 'Jump again in mid-air!', cooldown: 60 },
            { name: 'BUILDER', bodyColor: '#0077b6', headColor: '#f4c45a', hairColor: null, hasHelmet: true, hasMask: false, hasWizardHat: false,
              ability: 'BUILD PLATFORM', abilityDesc: 'Create a temporary platform!', cooldown: 180 },
            { name: 'NINJA', bodyColor: '#2d6a4f', headColor: '#f4c45a', hairColor: null, hasHelmet: false, hasMask: true, hasWizardHat: false,
              ability: 'DASH', abilityDesc: 'Super speed dash!', cooldown: 90 },
            { name: 'WIZARD', bodyColor: '#7b2cbf', headColor: '#f4c45a', hairColor: null, hasHelmet: false, hasMask: false, hasWizardHat: true,
              ability: 'FIREBALL', abilityDesc: 'Shoot a magic fireball!', cooldown: 120 }
        ];
        let currentChar = 0;
        let canDoubleJump = false;
        let tempPlatforms = [];
        let fireballs = [];

        // Player
        const player = { x: 50, y: 300, width: 40, height: 60, velX: 0, velY: 0, speed: 5, jumping: false, grounded: false, facingRight: true };

        // Physics
        const gravity = 0.6, friction = 0.8, jumpForce = -14;

        // Boss types (evil versions of each character)
        const bossTypes = [
            { name: 'DARK ADVENTURER', bodyColor: '#8B0000', headColor: '#f4c45a', hairColor: '#222', level: 25, health: 5 },
            { name: 'ROBO BUILDER', bodyColor: '#003366', headColor: '#888', isRobot: true, level: 50, health: 7 },
            { name: 'SHADOW NINJA', bodyColor: '#0a0a0a', headColor: '#333', hasMask: true, level: 75, health: 9 },
            { name: 'EVIL WIZARD', bodyColor: '#4a0080', headColor: '#f4c45a', hasWizardHat: true, level: 100, health: 12 }
        ];

        // Enemy types
        const enemyTypes = [
            { name: 'ROBOT', bodyColor: '#666', headColor: '#888', eyeColor: '#ff0000', isRobot: true },
            { name: 'SKELETON', bodyColor: '#f5f5dc', headColor: '#f5f5dc', eyeColor: '#000', isSkeleton: true },
            { name: 'VILLAIN', bodyColor: '#222', headColor: '#f4c45a', eyeColor: '#222', isVillain: true }
        ];

        let platforms = [], enemies = [], studs = [], particles = [];
        let boss = null, bossProjectiles = [];

        // Generate level procedurally
        function generateLevel(levelNum) {
            platforms = [{ x: 0, y: 420, width: 800, height: 30, color: '#2d6a4f' }];
            enemies = [];
            studs = [];
            tempPlatforms = [];
            fireballs = [];
            bossProjectiles = [];
            boss = null;

            const isBossLevel = [25, 50, 75, 100].includes(levelNum);
            const difficulty = Math.min(levelNum / 10, 10);
            const colors = ['#e63946', '#0077b6', '#f9c74f', '#7b2cbf', '#f48c06', '#2d6a4f'];

            if (isBossLevel) {
                // Boss level - simple arena
                platforms.push({ x: 100, y: 320, width: 200, height: 25, color: colors[0] });
                platforms.push({ x: 500, y: 320, width: 200, height: 25, color: colors[1] });
                platforms.push({ x: 300, y: 220, width: 200, height: 25, color: colors[2] });
                platforms.push({ x: 50, y: 150, width: 150, height: 25, color: colors[3] });
                platforms.push({ x: 600, y: 150, width: 150, height: 25, color: colors[4] });

                // Spawn boss
                const bossIndex = [25, 50, 75, 100].indexOf(levelNum);
                const bossType = bossTypes[bossIndex];
                boss = {
                    x: 600, y: 350, width: 60, height: 80,
                    velX: 2, health: bossType.health, maxHealth: bossType.health,
                    type: bossIndex, attackTimer: 0, phase: 1
                };

                // Few studs
                for (let i = 0; i < 5; i++) {
                    studs.push({ x: 150 + i * 130, y: 280, collected: false });
                }
            } else {
                // Normal level - procedural generation (EASY MODE)
                const numPlatforms = 5 + Math.floor(levelNum / 8);
                let lastX = 50, lastY = 360;

                for (let i = 0; i < numPlatforms; i++) {
                    const width = 100 + Math.random() * 60; // Bigger platforms
                    const x = lastX + 60 + Math.random() * 50; // Smaller gaps
                    const y = Math.max(150, Math.min(380, lastY + (Math.random() - 0.5) * 80)); // Less height variation

                    if (x + width < 780) {
                        platforms.push({ x, y, width, height: 28, color: colors[i % colors.length] });
                        studs.push({ x: x + width/2 - 20, y: y - 30, collected: false });
                        studs.push({ x: x + width/2 + 20, y: y - 30, collected: false });
                        lastX = x;
                        lastY = y;
                    }
                }

                // Fewer and slower enemies
                const numEnemies = Math.min(1 + Math.floor(levelNum / 25), 3);
                for (let i = 0; i < numEnemies; i++) {
                    const platIndex = i % platforms.length;
                    const plat = platforms[platIndex];
                    enemies.push({
                        x: plat.x + 20, y: plat.y - 50, width: 35, height: 50,
                        velX: (0.8 + difficulty * 0.08) * (Math.random() > 0.5 ? 1 : -1), // Slower
                        type: i % 3, platIndex, alive: true
                    });
                }
            }

            player.x = 50;
            player.y = 300;
            player.velX = 0;
            player.velY = 0;
            document.getElementById('level').textContent = levelNum;
        }

        function createHotdogs() {
            for (let i = 0; i < 50; i++) {
                hotdogs.push({ x: Math.random() * canvas.width, y: -Math.random() * 300 - 50, velY: Math.random() * 3 + 2, rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.2 });
            }
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({ x, y, velX: (Math.random() - 0.5) * 8, velY: (Math.random() - 0.5) * 8 - 3, size: Math.random() * 8 + 4, color, life: 30 });
            }
        }

        function useAbility() {
            if (abilityCooldown > 0) return;

            const char = characters[currentChar];
            abilityCooldown = char.cooldown;

            switch(currentChar) {
                case 0: // Adventurer - Double Jump
                    canDoubleJump = true;
                    break;
                case 1: // Builder - Create Platform
                    tempPlatforms.push({ x: player.x - 30, y: player.y + player.height + 10, width: 80, height: 15, color: '#00b4d8', timer: 180 });
                    createParticles(player.x + 20, player.y + player.height, '#00b4d8', 5);
                    break;
                case 2: // Ninja - Dash
                    player.velX = player.facingRight ? 20 : -20;
                    invincible = true;
                    invincibleTimer = 15;
                    createParticles(player.x + 20, player.y + 30, '#2d6a4f', 8);
                    break;
                case 3: // Wizard - Fireball
                    fireballs.push({ x: player.x + 20, y: player.y + 25, velX: player.facingRight ? 10 : -10, size: 15 });
                    createParticles(player.x + 20, player.y + 25, '#ff6600', 5);
                    break;
            }
        }

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            if (keys[e.code]) return;
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyE'].includes(e.code)) e.preventDefault();
            if (e.code === 'Digit1') { currentChar = 0; updateCharDisplay(); }
            if (e.code === 'Digit2') { currentChar = 1; updateCharDisplay(); }
            if (e.code === 'Digit3') { currentChar = 2; updateCharDisplay(); }
            if (e.code === 'Digit4') { currentChar = 3; updateCharDisplay(); }
            if (e.code === 'KeyE') useAbility();

            // Double jump for adventurer
            if ((e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') && !player.grounded && canDoubleJump && currentChar === 0) {
                player.velY = jumpForce;
                canDoubleJump = false;
                createParticles(player.x + 20, player.y + 60, '#e63946', 5);
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function updateCharDisplay() {
            document.getElementById('character').textContent = characters[currentChar].name;
            document.getElementById('abilityName').textContent = characters[currentChar].ability;
        }

        function drawBrick(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x, y, width, height/3);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x, y + height - 4, width, 4);

            const studRadius = Math.min(8, height/3);
            const studSpacing = studRadius * 3;
            for (let sx = x + studSpacing/2; sx < x + width - studRadius; sx += studSpacing) {
                ctx.beginPath();
                ctx.arc(sx, y, studRadius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sx, y, studRadius - 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fill();
            }
        }

        function drawMinifig(x, y, char, flash = false, scale = 1) {
            if (flash && Math.floor(Date.now() / 100) % 2 === 0) return;
            const c = typeof char === 'number' ? characters[char] : char;

            ctx.save();
            ctx.translate(x + 20 * scale, y + 30 * scale);
            ctx.scale(scale, scale);
            ctx.translate(-20, -30);

            // Legs
            ctx.fillStyle = '#1a1a8e';
            ctx.fillRect(5, 42, 12, 18);
            ctx.fillRect(23, 42, 12, 18);

            // Body
            ctx.fillStyle = c.bodyColor;
            ctx.fillRect(2, 20, 36, 24);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(2, 20, 36, 8);

            // Arms
            ctx.fillStyle = c.bodyColor;
            ctx.fillRect(-5, 20, 10, 18);
            ctx.fillRect(35, 20, 10, 18);

            // Hands
            ctx.fillStyle = c.headColor || '#f4c45a';
            ctx.beginPath(); ctx.arc(0, 40, 5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(40, 40, 5, 0, Math.PI * 2); ctx.fill();

            // Head
            ctx.fillStyle = c.headColor || '#f4c45a';
            ctx.fillRect(5, 0, 30, 22);

            if (c.hasMask) {
                ctx.fillStyle = c.bodyColor;
                ctx.fillRect(5, 0, 30, 22);
                ctx.fillStyle = c.headColor || '#f4c45a';
                ctx.fillRect(7, 8, 26, 8);
            }

            // Eyes
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.arc(14, 10, 3, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(26, 10, 3, 0, Math.PI * 2); ctx.fill();

            if (!c.hasMask) {
                ctx.beginPath();
                ctx.arc(20, 14, 8, 0.1 * Math.PI, 0.9 * Math.PI);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            if (c.hairColor) {
                ctx.fillStyle = c.hairColor;
                ctx.fillRect(5, -5, 30, 10);
                ctx.fillRect(5, 0, 6, 8);
            }

            if (c.hasHelmet) {
                ctx.fillStyle = '#f9c74f';
                ctx.beginPath();
                ctx.ellipse(20, 2, 20, 8, 0, Math.PI, 2 * Math.PI);
                ctx.fill();
                ctx.fillRect(0, -5, 40, 10);
            }

            if (c.isRobot) {
                ctx.fillStyle = '#888';
                ctx.fillRect(15, -8, 5, 10);
                ctx.beginPath();
                ctx.arc(17.5, -10, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
            }

            if (c.hasWizardHat) {
                ctx.fillStyle = c.bodyColor;
                ctx.beginPath();
                ctx.moveTo(20, -30);
                ctx.lineTo(0, 2);
                ctx.lineTo(40, 2);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ffd700';
                drawStar(20, -15, 5, 5, 3);
            }

            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            const b = bossTypes[boss.type];

            // Health bar
            ctx.fillStyle = '#333';
            ctx.fillRect(250, 20, 300, 20);
            ctx.fillStyle = '#e63946';
            ctx.fillRect(252, 22, (boss.health / boss.maxHealth) * 296, 16);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(b.name, 400, 35);

            // Draw boss (larger minifig)
            drawMinifig(boss.x, boss.y, b, false, 1.3);

            // Boss glow
            ctx.beginPath();
            ctx.arc(boss.x + 40, boss.y + 50, 50 + Math.sin(Date.now() / 200) * 5, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(123, 44, 191, ${0.3 + Math.sin(Date.now() / 200) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawEnemy(enemy) {
            if (!enemy.alive) return;
            const e = enemyTypes[enemy.type];
            const x = enemy.x, y = enemy.y;

            ctx.fillStyle = e.bodyColor;
            ctx.fillRect(x + 4, y + 35, 10, 15);
            ctx.fillRect(x + 21, y + 35, 10, 15);
            ctx.fillRect(x + 2, y + 16, 31, 20);

            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x + 2, y + 16, 31, 7);

            ctx.fillStyle = e.bodyColor;
            ctx.fillRect(x - 4, y + 16, 8, 15);
            ctx.fillRect(x + 31, y + 16, 8, 15);

            ctx.fillStyle = e.headColor;
            ctx.fillRect(x + 4, y, 27, 18);

            if (e.isRobot) {
                ctx.fillStyle = '#888';
                ctx.fillRect(x + 15, y - 8, 5, 10);
                ctx.beginPath();
                ctx.arc(x + 17.5, y - 10, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();
                ctx.fillStyle = e.eyeColor;
                ctx.fillRect(x + 8, y + 5, 8, 4);
                ctx.fillRect(x + 19, y + 5, 8, 4);
            }

            if (e.isSkeleton) {
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(x + 12, y + 7, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + 23, y + 7, 4, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f5f5dc';
                for (let i = 0; i < 5; i++) ctx.fillRect(x + 11 + i * 3, y + 14, 2, 4);
            }

            if (e.isVillain) {
                ctx.fillStyle = e.eyeColor;
                ctx.beginPath(); ctx.arc(x + 12, y + 7, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + 23, y + 7, 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.moveTo(x, y + 2); ctx.lineTo(x + 17.5, y - 10); ctx.lineTo(x + 35, y + 2);
                ctx.lineTo(x + 35, y); ctx.lineTo(x, y); ctx.closePath(); ctx.fill();
            }
        }

        function drawHotdog(hd) {
            ctx.save();
            ctx.translate(hd.x, hd.y);
            ctx.rotate(hd.rotation);
            ctx.fillStyle = '#daa520';
            ctx.beginPath(); ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#c1440e';
            ctx.beginPath(); ctx.ellipse(0, 0, 22, 6, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-18, 0);
            for (let i = 0; i < 6; i++) ctx.lineTo(-15 + i * 6, i % 2 === 0 ? -3 : 3);
            ctx.stroke();
            ctx.restore();
        }

        function drawStar(cx, cy, spikes, outerR, innerR) {
            let rot = Math.PI / 2 * 3, step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerR);
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
                rot += step;
                ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
                rot += step;
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawStud(x, y, collected) {
            if (collected) return;
            ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.fill();
            ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd700'; ctx.fill();
            ctx.beginPath(); ctx.arc(x - 2, y - 2, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fill();
        }

        function drawFireball(fb) {
            ctx.beginPath();
            ctx.arc(fb.x, fb.y, fb.size, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(fb.x, fb.y, 0, fb.x, fb.y, fb.size);
            grad.addColorStop(0, '#ffff00');
            grad.addColorStop(0.5, '#ff6600');
            grad.addColorStop(1, '#ff0000');
            ctx.fillStyle = grad;
            ctx.fill();
        }

        function checkCollision(r1, r2) {
            return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
        }

        function playerHit() {
            if (invincible) return;
            lives--;
            document.getElementById('lives').textContent = lives;

            if (lives <= 0) {
                gameRunning = false;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('enemiesDefeated').textContent = enemiesKilled;
                document.getElementById('gameOverTitle').textContent = 'GAME OVER';
                document.getElementById('bossText').textContent = 'You reached level ' + currentLevel;
                document.getElementById('gameOver').className = 'game-over';
                document.getElementById('buttonContainer').innerHTML = '<button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>';
                document.getElementById('gameOver').style.display = 'block';
            } else {
                invincible = true;
                invincibleTimer = 120;
                player.x = 50;
                player.y = 300;
                player.velX = 0;
                player.velY = 0;
            }
        }

        function levelComplete() {
            gameRunning = false;
            celebrating = true;
            createHotdogs();

            document.getElementById('finalScore').textContent = score;
            document.getElementById('enemiesDefeated').textContent = enemiesKilled;

            const isBossLevel = [25, 50, 75, 100].includes(currentLevel);

            if (currentLevel >= maxLevel) {
                document.getElementById('gameOverTitle').textContent = 'YOU BEAT ALL 100 LEVELS!';
                document.getElementById('bossText').textContent = 'ULTIMATE HOT DOG PARTY!';
                document.getElementById('buttonContainer').innerHTML = '<button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>';
            } else if (isBossLevel) {
                document.getElementById('gameOverTitle').textContent = 'BOSS DEFEATED!';
                document.getElementById('bossText').textContent = bossTypes[[25,50,75,100].indexOf(currentLevel)].name + ' has been vanquished!';
                document.getElementById('buttonContainer').innerHTML =
                    '<button class="restart-btn next-btn" onclick="nextLevel()">NEXT LEVEL</button>' +
                    '<button class="restart-btn" onclick="restartGame()">RESTART</button>';
                document.getElementById('gameOver').className = 'game-over win boss';
            } else {
                document.getElementById('gameOverTitle').textContent = 'LEVEL ' + currentLevel + ' COMPLETE!';
                document.getElementById('bossText').textContent = currentLevel % 25 === 24 ? 'BOSS FIGHT NEXT!' : '';
                document.getElementById('buttonContainer').innerHTML =
                    '<button class="restart-btn next-btn" onclick="nextLevel()">NEXT LEVEL</button>' +
                    '<button class="restart-btn" onclick="restartGame()">RESTART</button>';
                document.getElementById('gameOver').className = 'game-over win';
            }

            document.getElementById('gameOver').style.display = 'block';
        }

        function nextLevel() {
            currentLevel++;
            celebrating = false;
            hotdogs = [];
            lives = 3; // Restore health every level!
            document.getElementById('lives').textContent = lives;
            generateLevel(currentLevel);
            gameRunning = true;
            document.getElementById('gameOver').style.display = 'none';
        }

        function update() {
            // Hotdogs
            if (celebrating) {
                for (let hd of hotdogs) {
                    hd.y += hd.velY;
                    hd.rotation += hd.rotSpeed;
                    if (hd.y > canvas.height + 50) { hd.y = -50; hd.x = Math.random() * canvas.width; }
                }
            }

            if (!gameRunning) return;

            // Cooldown
            if (abilityCooldown > 0) {
                abilityCooldown--;
                document.getElementById('cooldown').textContent = Math.ceil(abilityCooldown / 60) + 's';
            } else {
                document.getElementById('cooldown').textContent = 'READY';
            }

            // Invincibility
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) invincible = false;
            }

            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) { player.velX = Math.max(player.velX - 1, -player.speed); player.facingRight = false; }
            if (keys['ArrowRight'] || keys['KeyD']) { player.velX = Math.min(player.velX + 1, player.speed); player.facingRight = true; }
            if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded) {
                player.velY = jumpForce;
                player.grounded = false;
                if (currentChar === 0 && abilityCooldown <= 0) canDoubleJump = true;
            }

            // Physics
            player.velY += gravity;
            player.velX *= friction;
            player.x += player.velX;
            player.y += player.velY;

            // Platform collision (including temp platforms)
            const allPlatforms = [...platforms, ...tempPlatforms];
            player.grounded = false;
            for (let plat of allPlatforms) {
                if (checkCollision(player, plat)) {
                    if (player.velY > 0 && player.y + player.height - player.velY <= plat.y) {
                        player.y = plat.y - player.height;
                        player.velY = 0;
                        player.grounded = true;
                    } else if (player.velY < 0 && player.y - player.velY >= plat.y + plat.height) {
                        player.y = plat.y + plat.height;
                        player.velY = 0;
                    } else if (player.velX > 0) {
                        player.x = plat.x - player.width;
                    } else if (player.velX < 0) {
                        player.x = plat.x + plat.width;
                    }
                }
            }

            // Screen bounds
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            if (player.y > canvas.height) playerHit();

            // Temp platforms timer
            for (let i = tempPlatforms.length - 1; i >= 0; i--) {
                tempPlatforms[i].timer--;
                if (tempPlatforms[i].timer <= 0) tempPlatforms.splice(i, 1);
            }

            // Fireballs
            for (let i = fireballs.length - 1; i >= 0; i--) {
                let fb = fireballs[i];
                fb.x += fb.velX;
                if (fb.x < 0 || fb.x > canvas.width) { fireballs.splice(i, 1); continue; }

                // Hit enemies
                for (let enemy of enemies) {
                    if (enemy.alive && Math.abs(fb.x - enemy.x - 17) < 25 && Math.abs(fb.y - enemy.y - 25) < 30) {
                        enemy.alive = false;
                        enemiesKilled++;
                        score += 200;
                        document.getElementById('score').textContent = score;
                        createParticles(enemy.x + 17, enemy.y + 25, enemyTypes[enemy.type].bodyColor);
                        fireballs.splice(i, 1);
                        break;
                    }
                }

                // Hit boss
                if (boss && Math.abs(fb.x - boss.x - 40) < 40 && Math.abs(fb.y - boss.y - 50) < 50) {
                    boss.health--;
                    createParticles(boss.x + 40, boss.y + 50, '#ff6600', 15);
                    fireballs.splice(i, 1);
                    if (boss.health <= 0) {
                        score += 1000;
                        document.getElementById('score').textContent = score;
                        createParticles(boss.x + 40, boss.y + 50, bossTypes[boss.type].bodyColor, 30);
                        boss = null;
                        levelComplete();
                        return;
                    }
                }
            }

            // Enemies
            for (let enemy of enemies) {
                if (!enemy.alive) continue;
                enemy.x += enemy.velX;

                let plat = platforms[enemy.platIndex];
                if (enemy.platIndex === 0) {
                    if (enemy.x <= 10 || enemy.x + enemy.width >= canvas.width - 10) enemy.velX *= -1;
                } else if (plat) {
                    if (enemy.x <= plat.x || enemy.x + enemy.width >= plat.x + plat.width) enemy.velX *= -1;
                }

                if (checkCollision(player, enemy)) {
                    if (player.velY > 0 && player.y + player.height - player.velY <= enemy.y + 10) {
                        enemy.alive = false;
                        enemiesKilled++;
                        score += 200;
                        document.getElementById('score').textContent = score;
                        player.velY = jumpForce * 0.6;
                        createParticles(enemy.x + 17, enemy.y + 25, enemyTypes[enemy.type].bodyColor);
                    } else {
                        playerHit();
                    }
                }
            }

            // Boss AI
            if (boss) {
                boss.x += boss.velX;
                if (boss.x <= 50 || boss.x >= canvas.width - 100) boss.velX *= -1;

                boss.attackTimer++;
                if (boss.attackTimer > 90) {
                    boss.attackTimer = 0;
                    // Boss shoots projectile
                    const dx = player.x - boss.x;
                    const dy = player.y - boss.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    bossProjectiles.push({
                        x: boss.x + 40, y: boss.y + 50,
                        velX: (dx / dist) * 5, velY: (dy / dist) * 5
                    });
                }

                // Boss collision with player
                if (checkCollision(player, boss)) {
                    if (player.velY > 0 && player.y + player.height - player.velY <= boss.y + 10) {
                        boss.health--;
                        player.velY = jumpForce * 0.8;
                        createParticles(boss.x + 40, boss.y + 20, bossTypes[boss.type].bodyColor, 10);
                        if (boss.health <= 0) {
                            score += 1000;
                            document.getElementById('score').textContent = score;
                            createParticles(boss.x + 40, boss.y + 50, bossTypes[boss.type].bodyColor, 30);
                            boss = null;
                            levelComplete();
                            return;
                        }
                    } else {
                        playerHit();
                    }
                }
            }

            // Boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                let proj = bossProjectiles[i];
                proj.x += proj.velX;
                proj.y += proj.velY;
                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                if (Math.abs(proj.x - player.x - 20) < 25 && Math.abs(proj.y - player.y - 30) < 35) {
                    playerHit();
                    bossProjectiles.splice(i, 1);
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.velX;
                p.y += p.velY;
                p.velY += 0.3;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Studs
            for (let stud of studs) {
                if (!stud.collected) {
                    const dx = (player.x + 20) - stud.x;
                    const dy = (player.y + 30) - stud.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 30) {
                        stud.collected = true;
                        score += 100;
                        document.getElementById('score').textContent = score;
                    }
                }
            }

            // Win condition (no boss level)
            if (!boss && studs.every(s => s.collected) && enemies.every(e => !e.alive)) {
                levelComplete();
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            for (let i = 0; i < 40; i++) {
                ctx.beginPath();
                ctx.arc((i * 137) % canvas.width, (i * 89) % (canvas.height - 80), 1 + (i % 2), 0, Math.PI * 2);
                ctx.fill();
            }

            // Level number background
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.font = 'bold 120px Arial Black';
            ctx.textAlign = 'center';
            ctx.fillText(currentLevel, canvas.width/2, canvas.height/2 + 40);

            // Platforms
            for (let plat of platforms) drawBrick(plat.x, plat.y, plat.width, plat.height, plat.color);
            for (let plat of tempPlatforms) {
                ctx.globalAlpha = plat.timer / 180;
                drawBrick(plat.x, plat.y, plat.width, plat.height, plat.color);
                ctx.globalAlpha = 1;
            }

            // Studs
            for (let stud of studs) drawStud(stud.x, stud.y, stud.collected);

            // Enemies
            for (let enemy of enemies) drawEnemy(enemy);

            // Boss
            drawBoss();

            // Boss projectiles
            ctx.fillStyle = '#7b2cbf';
            for (let proj of bossProjectiles) {
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 12, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(123, 44, 191, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Fireballs
            for (let fb of fireballs) drawFireball(fb);

            // Particles
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                ctx.globalAlpha = 1;
            }

            // Player
            drawMinifig(player.x, player.y, currentChar, invincible);

            // Hotdogs
            for (let hd of hotdogs) drawHotdog(hd);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            score = 0;
            lives = 3;
            enemiesKilled = 0;
            currentLevel = 1;
            invincible = false;
            invincibleTimer = 0;
            celebrating = false;
            hotdogs = [];
            particles = [];
            abilityCooldown = 0;
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            generateLevel(1);
            gameRunning = true;
            document.getElementById('gameOver').style.display = 'none';
        }

        // Start
        generateLevel(1);
        updateCharDisplay();
        gameLoop();
    </script>
</body>
</html>